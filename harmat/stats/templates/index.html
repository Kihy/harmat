<!DOCTYPE html>
<html>

<head>
    <meta content="text/html;charset=utf-8" http-equiv="Content-Type">
    <meta content="utf-8" http-equiv="encoding">
    <title>HARM Visualisation Tool</title>
    <script type="text/javascript" src="{{ url_for('static', filename='d3.v3.min.js') }}"></script>
    <script type="text/javascript" src="{{ url_for('static', filename='d3.tip.v0.6.3.js') }}"></script>
    <script type="text/javascript" src="{{ url_for('static', filename='jquery-1.12.0.min.js') }}"></script>
    <script type="text/javascript" src="{{ url_for('static', filename='helper.js') }}"></script>
    <script type="text/javascript" src="{{ url_for('static', filename='Chart.min.js') }}"></script>
    <link href='https://fonts.googleapis.com/css?family=Roboto+Condensed' rel='stylesheet' type='text/css'>
    <style>
        body {
        }

        .node {
            stroke: #fff;
            stroke-width: 1px;
        }

        .link {
            stroke: #999;
            stoke-width: 1px;
        }

        .d3-tip {
            font-family: 'Roboto Condensed', sans-serif;
            font-weight: normal;
            line-height: 1;
            padding: 12px;
            background: rgba(0, 0, 0, 0.8);
            color: #fff;
            border-radius: 2px;
        }

        .d3-tip:after {
            box-sizing: border-box;
            display: inline;
            font-size: 10px;
            width: 100%;
            line-height: 1;
            color: rgba(0, 0, 0, 0.8);
            content: "\25BC";
            position: absolute;
            text-align: center;
        }

        .d3-tip.n:after {
            margin: -1px 0 0 0;
            top: 100%;
            left: 0;
        }

        .textClass {
            stroke: #323232;
            font-family: 'Roboto Condensed', sans-serif;
            font-weight: normal;
            stroke-width: .5;
            font-size: 14px;
        }

        p {
            stroke: #323232;
            font-family: 'Roboto Condensed', sans-serif;
            font-weight: normal;
            stroke-width: .5;
            font-size: 14px;
        }
    </style>
</head>

<body>
<button onclick="addNodes()">Restart Animation</button>
<script>
    function myGraph() {
        // Add and remove elements on the graph object
        this.addNode = function (id) {
            nodes.push({
                "id": id
            });
        };

        this.addNode_json = function (in_node, group) {
            if (in_node.type == "host") {
                in_node.collapsing = 0;
                in_node.collapsed = true;
            } else {
                in_node.collapsing = 1;
                in_node.collapsed = false;
            }
            in_node.group = group;
            nodes.push(in_node);
        };


        this.removeNode = function (id) {
            var i = 0;
            var n = findNode(id);
            while (i < links.length) {
                if ((links[i]['source'] == n) || (links[i]['target'] == n)) {
                    links.splice(i, 1);
                } else i++;
            }
            nodes.splice(findNodeIndex(id), 1);
        };

        this.removeLink = function (source, target) {
            for (var i = 0; i < links.length; i++) {
                if (links[i].source.id == source && links[i].target.id == target) {
                    links.splice(i, 1);
                    break;
                }
            }
        };

        this.removeallLinks = function () {
            links.splice(0, links.length);
        };

        this.removeAllNodes = function () {
            nodes.splice(0, links.length);
        };

        this.addLink = function (source, target, value) {
            links.push({
                "source": findNode(source),
                "target": findNode(target),
                "value": value
            });
        };

        //add a link based on the source/target id
        this.addLinkbyID = function (source, target, id) {
            var source_node = findNode(source);
            var target_node = findNode(target);
            links.push({
                "source": source_node,
                "target": target_node,
                "id": id
            });
        };

        //add link based on the index of the nodes
        this.addLinkbyIndex = function (source, target, id) {
            links.push({
                "source": nodes[source],
                "target": nodes[target],
                "id": id
            });
        };

        var findNode = function (id) {
            for (var i in nodes) {
                if (nodes[i]["id"] === id) return nodes[i];
            }
        };

        var findNodeIndex = function (id) {
            for (var i = 0; i < nodes.length; i++) {
                if (nodes[i].id == id) {
                    return i;
                }
            }
        };

        // set up the D3 visualisation in the specified element
        var w = 400,
            h = 400;

        var color = d3.scale.category10();

        //zoom
        var zoom = d3.behavior.zoom()
        //.scaleExtent([1,10])
                .on("zoom", zoomed);

        function zoomed() {
            vis.attr("transform", "translate(" + d3.event.translate + ")scale(" + d3.event.scale + ")");
        }

        var vis = d3.select("body")
                .append("svg:svg")
                .attr("width", w)
                .attr("height", h)
                .attr("id", "svg")
                .attr("pointer-events", "all")
                .attr("viewBox", "0 0 " + w + " " + h)
                .attr("perserveAspectRatio", "xMinYMid")
                .call(zoom)
                .on("dblclick.zoom", null)
                .append('svg:g');

        //tooltip
        var tip = d3.tip()
                .attr('class', 'd3-tip')
                .offset([-10, 0])
                .html(function (d) {
                    if (d.type == "host") {
                        return "<span style='color:" + color_chooser(d) + "'>" + d.name + "<br/>Risk: " + d.value + "<br/>Centrality: " + d.centrality + "</span>";
                    } else {
                        return "<span style='color:" + color_chooser(d) + "'>" + d.name + "<br/>Risk: " + d.value + "</span>";
                    }

                });
        vis.call(tip);


        //create force layout
        var force = d3.layout.force();
        force
                .charge(-400)
                .linkDistance(50)
                .size([w, h]);
        //.friction(0.7);

        var drag = force.drag()
                .origin(function (d) {
                    return d;
                })
                .on("dragstart", dragstarted)
                .on("drag", dragged);

        function dragstarted(d) {
            d3.event.sourceEvent.stopPropagation();
        }

        function dragged(d) {
            d3.select(this).attr("x", d.x = d3.event.x).attr("y", d.y = d3.event.y);
        }

        var nodes = force.nodes(),
                links = force.links();
        toggle = 0; //opacity_toggle
        var update = function () {

            //filter out nodes which should not be displayed
            update_nodes = nodes.filter(function (d) {
                return d.collapsing == 0;
            });

            update_links = links.filter(function (d) {
                return d.source.collapsing == 0 && d.target.collapsing == 0;
            });


            // Restart the force layout.
            force
                    .nodes(update_nodes)
                    .links(update_links)
                    .start();
            //select link
            var link = vis.selectAll("line")
                    .data(update_links, function (d) {
                        return d.source.id + "-" + d.target.id;
                    });

            //exit
            link.exit().remove();

            //enter
            link.enter().append("line")
                    .attr("id", function (d) {
                        return d.source.id + "-" + d.target.id;
                    })
                    .attr("stroke-width", function (d) {
                        return "1.5px";
                    })
                    .style("stroke-dasharray", function (d) {
                        if (d.source.type == "host" && d.target.type !== "host") {
                            return ("6, 6");
                        } else {
                            return ("0, 0");
                        }
                    })
                    .attr("class", "link");

            link.append("title")
                    .text(function (d) {
                        return d.value;
                    });

            //select node
            var node = vis.selectAll(".node")
                    .on('mouseover', tip.show)
                    .on('mouseout', tip.hide)
                    .data(update_nodes, function (d) {
                        return d.id;
                    });

            //exit
            node.exit().remove();

            //enter
            var nodeEnter = node.enter().append("g")
                    .attr("class", "node")
                    .on("dblclick", click) //Click
                    .on("contextmenu", click_single) //right click
                    .call(force.drag().on("drag", function (d) {
                        drag;
                    }));

            //recurse through the attack tree and toggle the states of each node.
            function recurse(d, state) {
                links.forEach(function (l) {
                    if (l.source.id == d.id && l.target.type !== "host") {
                        if (state == 0) {
                            l.target.collapsing = 1;
                            d.collapsed = true;
                            recurse(l.target, 0);
                        } else if (state == 1) {
                            l.target.collapsing = 0;
                            d.collapsed = false;
                            recurse(l.target, 1);
                        }

                        if (d.collapsed) {
                            l.target.collapsing = 0;
                            recurse(l.target, 0);
                        } else {
                            l.target.collapsing = 1;
                            recurse(l.target, 1);
                        }

                    }

                });
                d.collapsed = !d.collapsed;
            }

            function click(d) {
                if (!d3.event.defaultPrevented) { //ignores drag
                    recurse(d, 3);

                }
                update();
                update();
            }


            //fades out other nodes in the graph
            function click_single(d) {
                node = vis.selectAll(".node");
                link = vis.selectAll(".link");
                d3.event.preventDefault(); //prevents right click popup
                if (toggle == 0) {
                    d = d3.select(this).node().__data__;
                    node.style("opacity", function (o) {
                        if (d.group === o.group) {
                            return 1;
                        } else {
                            return 0.1;
                        }
                    });

                    link.style("opacity", function (o) {
                        if (d.group == o.source.group && d.group == o.target.group) {
                            return 1;
                        } else {
                            return 0.1;
                        }
                    });
                    toggle = 1;
                } else {
                    node.style("opacity", 1);
                    link.style("opacity", 1);
                    toggle = 0;
                }
                update();
                update();
            }

            nodeEnter.append("svg:circle")
                    .attr("r", 12)
                    .attr("class", "nodeStrokeClass")
                    .attr("r", function (d) {
                        return calc_radius(d);
                    })
                    .style("fill", function (d) {
                        if (d.type == "host") {
                            return color_chooser(d);
                        } else {
                            return "white";
                        }
                    })
                    .style("stroke-width", function (d) {
                        if (d.type == "host") {
                            return 0;
                        } else {
                            return calc_radius(d) * 0.7;
                        }
                    })
                    .style("stroke", function (d) {
                        return color_chooser(d);
                    });

            nodeEnter.append("svg:text")
                    .attr("class", "textClass")
                    .attr("x", 15)
                    .attr("y", 3)
                    .text(function (d) {
                        return d.name;
                        /*
                         if(d.value >= 0) {
                         return d.name;
                         } else {
                         return;
                         }
                         */
                    });


            force.on("tick", function () {
                node.attr("transform", function (d) {
                    return "translate(" + d.x + "," + d.y + ")";
                });


                link.attr("x1", function (d) {
                    return d.source.x;
                })
                        .attr("y1", function (d) {
                            return d.source.y;
                        })
                        .attr("x2", function (d) {
                            return d.target.x;
                        })
                        .attr("y2", function (d) {
                            return d.target.y;
                        });

            });

            keepNodesOnTop();
        };

        this.update_g = function () {
            update();
            update();
        }
    }

    function drawGraph() {


        graph = new myGraph("#svgdiv");

        d3.xml("/data", function (error, xml) {
            if (error) throw error;

            function convert_children(node, group) {
                var d = {};
                d.id = node.querySelector("id").textContent;
                d.name = node.querySelector("name").textContent;
                d.value = node.querySelector("value").textContent;
                d.group = group;
                d.type = "treenode";
                d.children = [];
                var data = [].map.call(node.querySelector("children").querySelectorAll(":scope > treenode"), function (e) {
                    d.children.push(convert_children(e, group));
                });
                d.collapsing = 1;
                d.collapsed = false;
                return d;
            }


            function create_js_format(xml_host, group) {
                var d = {};
                d.id = xml_host.querySelector("id").textContent;
                d.name = xml_host.querySelector("name").textContent;
                d.value = xml_host.querySelector("value").textContent;
                d.centrality = parseFloat(xml_host.querySelector("centrality").textContent);
                d.group = group;
                d.type = "host";
                d.children = [];
                temp = xml_host.querySelector("treenode");
                if (temp.querySelector("id") !== null) {
                    d.children.push(convert_children(temp, group));
                }
                d.collapsing = 0;
                d.collapsed = true;
                return d;
            }

            function create_js_link(source_val, target_val) {
                var l = {};
                l.source = source_val;
                l.target = target_val;
                return l
            }

            var data = {};
            data.nodes = [];
            data.links = [];
            [].map.call(xml.querySelectorAll("host"), function (host) {
                data.nodes.push(create_js_format(host, host.querySelector("id").textContent));
            });


            [].map.call(xml.querySelector("links").querySelectorAll("link"), function (link_xml) {
                data.links.push(create_js_link(link_xml.querySelector("source").textContent, link_xml.querySelector("target").textContent));
            });

            var link_id_counter = 0;
            //add upper layer nodes
            data.nodes.forEach(function (d) {
                graph.addNode_json(d, d.id);
            });
            //add upper layer links
            data.links.forEach(function (d) {
                graph.addLinkbyIndex(d.source, d.target, link_id_counter);
                link_id_counter++;
                keepNodesOnTop();
            });

            //add lower layer nodes/links

            // group is used to indicate that nodes are in the same AT.
            // Used when fading out other nodes.

            var addChildren = function (d, group) {
                d.children.forEach(function (e) {
                    graph.addNode_json(e, group);
                    if (d.children !== []) {
                        graph.addLinkbyID(d.id, e.id, link_id_counter);
                        link_id_counter++;
                        keepNodesOnTop();
                        addChildren(e, group);
                    }
                });
            };


            data.nodes.forEach(function (d) {
                current_group = d.id;
                addChildren(d, current_group);
            });

            graph.update_g();
        });


    }

    drawGraph();

    // because of the way the network is created, nodes are created first, and links second,
    // so the lines were on top of the nodes, this just reorders the DOM to put the svg:g on top
    function keepNodesOnTop() {
        $(".nodeStrokeClass").each(function (index) {
            var gnode = this.parentNode;
            gnode.parentNode.appendChild(gnode);
        });
    }

    function addNodes() {
        d3.select("svg")
                .remove();
        drawGraph();
    }
</script>

<div class="container">
    <p>Number of nodes: {{ num_nodes }}</p>
    <p>Number of edges: {{ num_edges }}</p>
    <p>Highest Risk: {{ highest_risk }}</p>
    <p>Source name: {{ source }}</p>
    <p>Target name: {{ target }}</p>
    <p>Risk: {{ risk }}</p>
    <p>Return on Attack: {{ roa }}</p>
    <p>Mode of Path Length: {{ mopl }}</p>
    <p>Mean of Path Length: {{ mpl }}</p>
    <p>Standard deviation of path length: {{ sdpl }}</p>
    <p>Shortest path length: {{ sp }}</p>
</div>
<script src="http://code.jquery.com/jquery-1.10.2.min.js"></script>
<script src="http://netdna.bootstrapcdn.com/bootstrap/3.0.0/js/bootstrap.min.js"></script>
</body>
<canvas id="myChart" width="100" height="100"></canvas>
<script>
    var ctx = $("#myChart");
    var data = {
        labels: ["Number of nodes", "Number of edges", "Highest Risk", "Mode of Path lengths", "Mean of Path lengths", "Standard Deviation of Pathlengths", "Shortest Path length"],
        datasets: [
            {
                label: "Harm 1",
                backgroundColor: "rgba(179,181,198,0.2)",
                borderColor: "rgba(179,181,198,1)",
                pointBackgroundColor: "rgba(179,181,198,1)",
                pointBorderColor: "#fff",
                pointHoverBackgroundColor: "#fff",
                pointHoverBorderColor: "rgba(179,181,198,1)",
                data: [{{ num_nodes }}, {{ num_edges }}, {{ highest_risk }}, {{ mopl }}, {{ mpl }}, {{ sdpl }}, {{ sp }}]
            },
        ]
    };
    var myRadarChart = new Chart(ctx, {
        type: 'radar',
        data: data
        //options: options
    });
</script>
</html>